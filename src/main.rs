#![allow(
    clippy::uninlined_format_args,
    clippy::collapsible_else_if,
    clippy::wildcard_in_or_patterns,
    clippy::too_many_arguments,
    clippy::unnecessary_map_or
)]

// Use modules from the library crate
use gitai::{
    args::{ConfigAction, PromptAction},
    config::{self},
    git,
};

#[cfg(feature = "metrics")]
use gitai::args::MetricsAction;

// Conditionally import feature-gated modules
#[cfg(feature = "ai")]
use gitai::ai;

#[cfg(feature = "security")]
use gitai::scan;

#[cfg(feature = "update-notifier")]
use gitai::update;

#[cfg(feature = "metrics")]
use gitai::metrics;

// Always available modules (used in legacy code)
#[allow(unused_imports)]
use gitai::{commit, features, review};

use std::fs;
use std::path::PathBuf;
type Result<T> = std::result::Result<T, Box<dyn std::error::Error + Send + Sync + 'static>>;

fn init_logger() {
    use std::io::Write;

    env_logger::Builder::from_default_env()
        .filter_level(log::LevelFilter::Info)
        .format(|buf, record| {
            let level_style = match record.level() {
                log::Level::Error => "\x1b[31m", // Á∫¢Ëâ≤
                log::Level::Warn => "\x1b[33m",  // ÈªÑËâ≤
                log::Level::Info => "\x1b[32m",  // ÁªøËâ≤
                log::Level::Debug => "\x1b[36m", // ÈùíËâ≤
                log::Level::Trace => "\x1b[90m", // ÁÅ∞Ëâ≤
            };

            writeln!(
                buf,
                "{}{} [{}] {}",
                level_style,
                chrono::Local::now().format("%H:%M:%S"),
                record.level(),
                record.args()
            )
        })
        .init();
}

/// Ëé∑ÂèñÁºìÂ≠òÁõÆÂΩï
#[allow(dead_code)]
fn get_cache_dir() -> Result<PathBuf> {
    let cache_dir = dirs::home_dir()
        .unwrap_or_else(|| PathBuf::from("."))
        .join(".cache")
        .join("gitai");

    fs::create_dir_all(&cache_dir)?;
    Ok(cache_dir)
}

mod cli;

#[tokio::main]
async fn main() -> Result<()> {
    init_logger();

    let args = gitai::args::Args::parse();
    let mut app = cli::CliApp::new(args);

    // Initialize configuration if needed
    app.initialize().await?;

    // Run the application
    app.run().await
}

// All command handling is now managed by cli::CliApp
// Legacy command handling code has been fully migrated to cli::handlers module
/*
        Command::Review {
            language,
            format,
            output,
            tree_sitter,
            security_scan,
            scan_tool,
            block_on_critical,
            issue_id,
            space_id,
            full,
            ..
        } => {
            let review_config = review::ReviewConfig::from_args(
                language,
                format,
                output,
                tree_sitter,
                security_scan,
                scan_tool,
                block_on_critical,
                issue_id,
                space_id,
                full,
            );
            review::execute_review(&config, review_config).await?;
        }
        #[cfg(feature = "security")]
        Command::Scan {
            path,
            tool,
            full,
            remote,
            update_rules,
            format,
            output,
            translate,
            auto_install,
            lang,
            no_history,
            timeout,
            benchmark,
        } => {
            handle_scan(
                &config,
                &path,
                &tool,
                full,
                remote,
                update_rules,
                &format,
                output,
                translate,
                auto_install,
                lang.as_deref(),
                no_history,
                timeout,
                benchmark,
            )
            .await?;
        }
        #[cfg(not(feature = "security"))]
        Command::Scan { .. } => {
            eprintln!("‚ùå ÂÆâÂÖ®Êâ´ÊèèÂäüËÉΩÊú™ÂêØÁî®");
            eprintln!("üí° ËØ∑‰ΩøÁî®ÂåÖÂê´ 'security' ÂäüËÉΩÁöÑÊûÑÂª∫ÁâàÊú¨");
            return Err("ÂäüËÉΩÊú™ÂêØÁî®".into());
        }
        #[cfg(feature = "security")]
        Command::ScanHistory { limit, format: _ } => {
            handle_scan_history(limit)?;
        }
        #[cfg(not(feature = "security"))]
        Command::ScanHistory { .. } => {
            eprintln!("‚ùå ÂÆâÂÖ®Êâ´ÊèèÂéÜÂè≤ÂäüËÉΩÊú™ÂêØÁî®");
            eprintln!("üí° ËØ∑‰ΩøÁî®ÂåÖÂê´ 'security' ÂäüËÉΩÁöÑÊûÑÂª∫ÁâàÊú¨");
            return Err("ÂäüËÉΩÊú™ÂêØÁî®".into());
        }
        Command::Prompts { action } => {
            handle_prompts_action(&config, &action).await?;
        }
        Command::Commit {
            message,
            issue_id,
            space_id,
            all,
            review,
            tree_sitter,
            dry_run,
        } => {
            let commit_config = commit::CommitConfig::from_args(
                message,
                issue_id,
                space_id,
                all,
                review,
                tree_sitter,
                dry_run,
            );
            commit::execute_commit(&config, commit_config).await?;
        }
        #[cfg(feature = "update-notifier")]
        Command::Update { check, format } => {
            if check {
                handle_update_check(&config, &format).await?;
            } else {
                handle_update(&config).await?;
            }
        }
        #[cfg(not(feature = "update-notifier"))]
        Command::Update { .. } => {
            eprintln!("‚ùå Êõ¥Êñ∞ÂäüËÉΩÊú™ÂêØÁî®");
            eprintln!("üí° ËØ∑‰ΩøÁî®ÂåÖÂê´ 'update-notifier' ÂäüËÉΩÁöÑÊûÑÂª∫ÁâàÊú¨");
            return Err("ÂäüËÉΩÊú™ÂêØÁî®".into());
        }
        Command::Git(git_args) => {
            // ÈªòËÆ§‰∏çÂêØÁî®AIËß£ÈáäÔºõ--ai ÊòæÂºèÂºÄÂêØÔºõ--noai ÂèØÊòæÂºèÂÖ≥Èó≠ÔºàÂΩìÂ§ñÈÉ®Âà´ÂêçÂº∫Âà∂ÂºÄÂêØÊó∂Ôºâ
            let use_ai = args.ai && !args.noai;

            #[cfg(feature = "ai")]
            {
                if use_ai {
                    handle_git_with_ai(&config, &git_args).await?;
                } else {
                    let output = git::run_git(&git_args)?;
                    print!("{output}");
                }
            }

            #[cfg(not(feature = "ai"))]
            {
                // Êú™ÂêØÁî® AI Êó∂ÔºåÊÄªÊòØÁõ¥Êé•ÊâßË°å git
                let output = git::run_git(&git_args)?;
                print!("{output}");
            }
        }
        #[cfg(feature = "mcp")]
        Command::Mcp { transport, addr } => {
            handle_mcp(&config, &transport, &addr).await?;
        }
        #[cfg(not(feature = "mcp"))]
        Command::Mcp { .. } => {
            eprintln!("‚ùå MCP ÊúçÂä°Âô®ÂäüËÉΩÊú™ÂêØÁî®");
            eprintln!("üí° ËØ∑‰ΩøÁî®ÂåÖÂê´ 'mcp' ÂäüËÉΩÁöÑÊûÑÂª∫ÁâàÊú¨");
            return Err("ÂäüËÉΩÊú™ÂêØÁî®".into());
        }
        Command::Init { .. } => {
            // Â∑≤Âú®‰∏äÈù¢Â§ÑÁêÜ
            unreachable!()
        }
        Command::Config { action } => {
            handle_config(&config, &action, args.offline).await?;
        }
        #[cfg(feature = "metrics")]
        Command::Metrics { action } => {
            handle_metrics(&config, &action).await?;
        }
        #[cfg(not(feature = "metrics"))]
        Command::Metrics { .. } => {
            eprintln!("‚ùå Â∫¶ÈáèÂäüËÉΩÊú™ÂêØÁî®");
            eprintln!("üí° ËØ∑‰ΩøÁî®ÂåÖÂê´ 'metrics' ÂäüËÉΩÁöÑÊûÑÂª∫ÁâàÊú¨");
            return Err("ÂäüËÉΩÊú™ÂêØÁî®".into());
        }
        Command::Graph {
            path,
            output,
            threshold,
            summary,
            radius,
            top_k,
            seeds_from_diff,
            summary_format,
            budget_tokens,
            community,
            comm_alg,
            max_communities,
            max_nodes_per_community,
            with_paths,
            path_samples,
            path_max_hops,
        } => {
            if summary {
                handle_graph_summary(
                    &path,
                    radius,
                    top_k,
                    budget_tokens,
                    seeds_from_diff,
                    &summary_format,
                    community,
                    &comm_alg,
                    max_communities,
                    max_nodes_per_community,
                    with_paths,
                    path_samples,
                    path_max_hops,
                    output.as_ref(),
                )
                .await?;
            } else {
                handle_graph_export(&path, output.as_ref(), threshold).await?;
            }
        }
        Command::Features { format } => {
            features::display_features(&format);
        }
    }

    Ok(())
}
*/

// The following helper functions have been migrated to cli::handlers module
// These are kept temporarily for reference and can be removed after full verification

#[allow(dead_code)]
async fn handle_graph_export(
    path: &std::path::Path,
    output: Option<&std::path::PathBuf>,
    threshold: f32,
) -> Result<()> {
    use gitai::architectural_impact::graph_export::export_dot_string;
    let dot = export_dot_string(path, threshold).await?;
    if let Some(out) = output {
        std::fs::write(out, dot)?;
        println!("üìÅ ‰æùËµñÂõæÂ∑≤ÂØºÂá∫: {}", out.display());
    } else {
        println!("{dot}");
    }
    Ok(())
}

#[allow(dead_code, clippy::too_many_arguments)]
async fn handle_graph_summary(
    path: &std::path::Path,
    radius: usize,
    top_k: usize,
    budget_tokens: usize,
    seeds_from_diff: bool,
    format: &str,
    with_communities: bool,
    comm_alg: &str,
    max_communities: usize,
    max_nodes_per_community: usize,
    with_paths: bool,
    path_samples: usize,
    path_max_hops: usize,
    output: Option<&std::path::PathBuf>,
) -> Result<()> {
    use gitai::architectural_impact::graph_export::export_summary_string;
    let summary = export_summary_string(
        path,
        radius,
        top_k,
        seeds_from_diff,
        format,
        budget_tokens,
        with_communities,
        comm_alg,
        max_communities,
        max_nodes_per_community,
        with_paths,
        path_samples,
        path_max_hops,
    )
    .await?;
    if let Some(out) = output {
        std::fs::write(out, &summary)?;
        println!("üìÅ ÂõæÊëòË¶ÅÂ∑≤ÂØºÂá∫: {}", out.display());
    } else {
        println!("{summary}");
    }
    Ok(())
}

// Êâ´ÊèèÁõ∏ÂÖ≥Â§ÑÁêÜÂáΩÊï∞
#[cfg(feature = "security")]
#[allow(dead_code)]
async fn handle_scan(
    config: &config::Config,
    path: &std::path::Path,
    tool: &str,
    _full: bool,
    _remote: bool,
    update_rules: bool,
    _format: &str,
    output: Option<PathBuf>,
    _translate: bool,
    _auto_install: bool,
    lang: Option<&str>,
    no_history: bool,
    timeout: Option<u64>,
    benchmark: bool,
) -> Result<()> {
    let show_progress = _format != "json";

    if show_progress {
        println!("üîç Ê≠£Âú®Êâ´Êèè: {}", path.display());
    }

    // Á°Æ‰øùÊâ´ÊèèÂ∑•ÂÖ∑Â∑≤ÂÆâË£Ö
    // Â∞Ü 'security' Êò†Â∞Ñ‰∏∫ 'opengrep' ‰ª•‰øùÊåÅÂêëÂêéÂÖºÂÆπÊÄß
    let normalized_tool = match tool {
        "security" => "opengrep",
        other => other,
    };

    if (normalized_tool == "opengrep" || normalized_tool == "auto")
        && !scan::is_opengrep_installed()
    {
        if _auto_install {
            if show_progress {
                println!("üîß Êú™Ê£ÄÊµãÂà∞ OpenGrepÔºåÊ≠£Âú®Ëá™Âä®ÂÆâË£Ö...");
            }
            if let Err(e) = scan::install_opengrep() {
                return Err(format!("OpenGrep ÂÆâË£ÖÂ§±Ë¥•: {}", e).into());
            }
        } else {
            return Err("Êú™Ê£ÄÊµãÂà∞ OpenGrepÔºåËØ∑ÂÖàÂÆâË£ÖÊàñ‰ΩøÁî® --auto-install ËøõË°åËá™Âä®ÂÆâË£Ö".into());
        }
    }

    // Êõ¥Êñ∞ËßÑÂàôÔºàÂ¶ÇÊûúÈúÄË¶ÅÔºâ
    if update_rules {
        if show_progress {
            println!("üîÑ Ê≠£Âú®Êõ¥Êñ∞Êâ´ÊèèËßÑÂàô...");
        }
        #[cfg(feature = "update-notifier")]
        {
            let updater = update::AutoUpdater::new(config.clone());
            if let Err(e) = updater.update_scan_rules().await {
                eprintln!("‚ö†Ô∏è ËßÑÂàôÊõ¥Êñ∞Â§±Ë¥•: {}", e);
            }
        }
        #[cfg(not(feature = "update-notifier"))]
        {
            eprintln!("‚ÑπÔ∏è  update-notifier ÂäüËÉΩÊú™ÂêØÁî®ÔºåË∑≥ËøáËßÑÂàôÊõ¥Êñ∞„ÄÇ");
        }
    }

    // ÊâßË°åÊâ´Êèè
    let result = if normalized_tool == "opengrep" || normalized_tool == "auto" {
        let include_version = show_progress && !benchmark;
        scan::run_opengrep_scan(config, path, lang, timeout, include_version)?
    } else {
        return Err(format!(
            "‰∏çÊîØÊåÅÁöÑÊâ´ÊèèÂ∑•ÂÖ∑: {} (ÊîØÊåÅÁöÑÂ∑•ÂÖ∑: opengrep, security, auto)",
            tool
        )
        .into());
    };

    // ‰øùÂ≠òÊâ´ÊèèÂéÜÂè≤ÔºàÊó†ËÆ∫ËæìÂá∫Ê†ºÂºèÔºâ
    if !(no_history || benchmark) {
        let cache_dir = get_cache_dir()?;
        let history_dir = cache_dir.join("scan_history");
        if let Err(e) = fs::create_dir_all(&history_dir) {
            eprintln!("‚ö†Ô∏è Êó†Ê≥ïÂàõÂª∫Êâ´ÊèèÂéÜÂè≤ÁõÆÂΩï: {}", e);
        }
        let ts = chrono::Utc::now().format("%Y%m%d%H%M%S");
        let history_file = history_dir.join(format!("scan_{}_{}.json", result.tool, ts));
        if let Ok(json) = serde_json::to_string(&result) {
            if let Err(e) = fs::write(&history_file, json) {
                eprintln!("‚ö†Ô∏è ÂÜôÂÖ•Êâ´ÊèèÂéÜÂè≤Â§±Ë¥•: {}", e);
            }
        }
    }

    // ËæìÂá∫ÁªìÊûú
    if _format == "json" {
        let json = serde_json::to_string_pretty(&result)?;
        if let Some(output_path) = output {
            fs::write(output_path, json)?;
        } else {
            println!("{}", json);
        }
    } else {
        if show_progress {
            println!("üìä Êâ´ÊèèÁªìÊûú:");
            println!("  Â∑•ÂÖ∑: {}", result.tool);
            println!("  ÁâàÊú¨: {}", result.version);
            println!("  ÊâßË°åÊó∂Èó¥: {:.2}s", result.execution_time);

            if !result.findings.is_empty() {
                println!("  ÂèëÁé∞ÈóÆÈ¢ò: {}", result.findings.len());
                for finding in result.findings.iter().take(5) {
                    println!(
                        "    - {} ({}:{})",
                        finding.title,
                        finding.file_path.display(),
                        finding.line
                    );
                }
                if result.findings.len() > 5 {
                    println!("    ... ËøòÊúâ {} ‰∏™ÈóÆÈ¢ò", result.findings.len() - 5);
                }
            } else {
                println!("  ‚úÖ Êú™ÂèëÁé∞ÈóÆÈ¢ò");
            }
        }
    }

    Ok(())
}

#[cfg(feature = "security")]
#[allow(dead_code)]
fn handle_scan_history(limit: usize) -> Result<()> {
    let cache_dir = get_cache_dir()?;
    let history_dir = cache_dir.join("scan_history");

    if !history_dir.exists() {
        println!("üìÅ Êâ´ÊèèÂéÜÂè≤ÁõÆÂΩï‰∏çÂ≠òÂú®");
        return Ok(());
    }

    // Ëé∑ÂèñÂéÜÂè≤Êñá‰ª∂
    let mut entries: Vec<_> = fs::read_dir(&history_dir)?
        .filter_map(|entry| entry.ok())
        .filter(|entry| entry.path().extension().and_then(|s| s.to_str()) == Some("json"))
        .collect();

    // Êåâ‰øÆÊîπÊó∂Èó¥ÊéíÂ∫èÔºàÊúÄÊñ∞ÁöÑÂú®ÂâçÔºâ
    entries.sort_by(|a, b| {
        let a_time = a
            .metadata()
            .and_then(|m| m.modified())
            .unwrap_or(std::time::SystemTime::UNIX_EPOCH);
        let b_time = b
            .metadata()
            .and_then(|m| m.modified())
            .unwrap_or(std::time::SystemTime::UNIX_EPOCH);
        b_time.cmp(&a_time)
    });

    println!("üìã Êâ´ÊèèÂéÜÂè≤ (ÊúÄËøë{}Ê¨°):", limit);
    println!();

    for (i, entry) in entries.iter().take(limit).enumerate() {
        let path = entry.path();
        if let Ok(content) = fs::read_to_string(&path) {
            if let Ok(result) = serde_json::from_str::<scan::ScanResult>(&content) {
                let modified = entry
                    .metadata()
                    .and_then(|m| m.modified())
                    .ok()
                    .and_then(|t| t.duration_since(std::time::SystemTime::UNIX_EPOCH).ok())
                    .and_then(|d| chrono::DateTime::from_timestamp(d.as_secs() as i64, 0))
                    .map(|dt| dt.format("%Y-%m-%d %H:%M:%S").to_string())
                    .unwrap_or_else(|| "Êú™Áü•Êó∂Èó¥".to_string());

                println!("{}. {} - {}", i + 1, modified, result.tool);
                println!("   ÊâßË°åÊó∂Èó¥: {:.2}s", result.execution_time);
                println!("   ÂèëÁé∞ÈóÆÈ¢ò: {}", result.findings.len());
                if !result.findings.is_empty() {
                    println!("   Ââç3‰∏™ÈóÆÈ¢ò:");
                    for finding in result.findings.iter().take(3) {
                        println!("     - {}", finding.title);
                    }
                }
                println!();
            }
        }
    }

    Ok(())
}

#[cfg(feature = "ai")]
#[allow(dead_code)]
async fn handle_git_with_ai(config: &config::Config, git_args: &[String]) -> Result<()> {
    // ÊâßË°åGitÂëΩ‰ª§
    let output = git::run_git(git_args)?;
    print!("{output}");

    // Ê∑ªÂä†AIËß£Èáä
    let command_str = format!("git {}", git_args.join(" "));
    let prompt = format!(
        "Áî®Êà∑ÂàöÂàöÊâßË°å‰∫Ü‰ª•‰∏ãGitÂëΩ‰ª§Ôºö\n\n{}\n\nÂëΩ‰ª§ËæìÂá∫Ôºö\n{}\n\nËØ∑ÁÆÄÊ¥ÅÂú∞Ëß£ÈáäËøô‰∏™ÂëΩ‰ª§ÁöÑ‰ΩúÁî®ÂíåËæìÂá∫ÁªìÊûú„ÄÇ",
        command_str,
        output.trim()
    );

    match ai::call_ai(config, &prompt).await {
        Ok(explanation) => {
            println!("\nü§ñ AIËß£Èáä:");
            println!("{explanation}");
        }
        Err(e) => {
            log::warn!("AIËß£ÈáäÂ§±Ë¥•: {e}");
        }
    }

    Ok(())
}

#[allow(dead_code)]
async fn handle_prompts_action(_config: &config::Config, action: &PromptAction) -> Result<()> {
    match action {
        PromptAction::Init => {
            println!("üîÑ Ê≠£Âú®ÂàùÂßãÂåñÊèêÁ§∫ËØçÁõÆÂΩï...");
            let prompts_dir = dirs::home_dir()
                .unwrap_or_else(|| PathBuf::from("."))
                .join(".config")
                .join("gitai")
                .join("prompts");

            fs::create_dir_all(&prompts_dir)?;

            // ÂàõÂª∫ÈªòËÆ§Ê®°Êùø
            let templates = [
                ("commit.md", include_str!("../assets/prompts/commit.md")),
                ("review.md", include_str!("../assets/prompts/review.md")),
            ];

            for (filename, content) in &templates {
                let file_path = prompts_dir.join(filename);
                if !file_path.exists() {
                    fs::write(&file_path, content)?;
                }
            }

            println!("‚úÖ ÊèêÁ§∫ËØçÁõÆÂΩïÂ∑≤Â∞±Áª™: {}", prompts_dir.display());
        }
        PromptAction::List => {
            let prompts_dir = dirs::home_dir()
                .unwrap_or_else(|| PathBuf::from("."))
                .join(".config")
                .join("gitai")
                .join("prompts");

            if !prompts_dir.exists() {
                println!("üìÅ ÊèêÁ§∫ËØçÁõÆÂΩï‰∏çÂ≠òÂú®ÔºåËØ∑ÂÖàËøêË°å: gitai prompts init");
                return Ok(());
            }

            println!("üìù ÂèØÁî®ÁöÑÊèêÁ§∫ËØçÊ®°Êùø:");
            let entries = fs::read_dir(&prompts_dir)?;
            for entry in entries.flatten() {
                let path = entry.path();
                if path.extension().and_then(|s| s.to_str()) == Some("md") {
                    if let Some(name) = path.file_name().and_then(|s| s.to_str()) {
                        println!("  - {name}");
                    }
                }
            }
        }
        PromptAction::Show { name, language: _ } => {
            let prompts_dir = dirs::home_dir()
                .unwrap_or_else(|| PathBuf::from("."))
                .join(".config")
                .join("gitai")
                .join("prompts");

            let file_path = prompts_dir.join(format!("{name}.md"));
            if file_path.exists() {
                let content = fs::read_to_string(&file_path)?;
                println!("üìù ÊèêÁ§∫ËØçÊ®°Êùø: {name}");
                println!("{content}");
            } else {
                println!("‚ùå Êú™ÊâæÂà∞ÊèêÁ§∫ËØçÊ®°Êùø: {name}");
            }
        }
        PromptAction::Update => {
            println!("üîÑ Êõ¥Êñ∞ÊèêÁ§∫ËØçÊ®°ÊùøÂäüËÉΩÊöÇÊú™ÂÆûÁé∞");
        }
    }

    Ok(())
}

#[allow(dead_code)]
async fn handle_init(
    config_url: Option<String>,
    offline: bool,
    _resources_dir: Option<PathBuf>,
    _dev: bool,
    download_resources: bool,
) -> Result<()> {
    use gitai::config_init::ConfigInitializer;

    println!("üöÄ ÂàùÂßãÂåñ GitAI ÈÖçÁΩÆ...");

    let mut initializer = ConfigInitializer::new();

    if let Some(url) = config_url {
        println!("üì• ‰ΩøÁî®ÈÖçÁΩÆURL: {url}");
        initializer = initializer.with_config_url(Some(url));
    }

    if offline {
        println!("üîå Á¶ªÁ∫øÊ®°ÂºèÂàùÂßãÂåñ");
        initializer = initializer.with_offline_mode(true);
    }

    match initializer.initialize().await {
        Ok(config_path) => {
            println!("‚úÖ ÈÖçÁΩÆÂàùÂßãÂåñÊàêÂäü!");
            println!("üìÅ ÈÖçÁΩÆÊñá‰ª∂: {}", config_path.display());

            // Â¶ÇÊûúÈúÄË¶Å‰∏ãËΩΩËµÑÊ∫ê
            if download_resources && !offline {
                println!();
                println!("üì¶ Ê≠£Âú®‰∏ãËΩΩËµÑÊ∫ê...");

                // ‰∏ãËΩΩ Tree-sitter queries
                println!("üå≥ ‰∏ãËΩΩ Tree-sitter queries...");
                match download_tree_sitter_resources().await {
                    Ok(()) => println!("‚úÖ Tree-sitter queries ‰∏ãËΩΩÂÆåÊàê"),
                    Err(e) => eprintln!("‚ö†Ô∏è  Tree-sitter queries ‰∏ãËΩΩÂ§±Ë¥•: {e}"),
                }

                // ‰∏ãËΩΩ OpenGrep ËßÑÂàôÔºàÂ¶ÇÊûúÂèØËÉΩÁöÑËØùÔºâ
                println!("üîí ‰∏ãËΩΩ OpenGrep ËßÑÂàô...");
                match download_opengrep_resources(&config_path).await {
                    Ok(()) => println!("‚úÖ OpenGrep ËßÑÂàô‰∏ãËΩΩÂÆåÊàê"),
                    Err(e) => eprintln!("‚ö†Ô∏è  OpenGrep ËßÑÂàô‰∏ãËΩΩÂ§±Ë¥•: {e}"),
                }

                println!("‚úÖ ËµÑÊ∫ê‰∏ãËΩΩÂÆåÊàêÔºÅ");
            } else if download_resources && offline {
                println!();
                println!("‚ö†Ô∏è  Á¶ªÁ∫øÊ®°Âºè‰∏ãÊó†Ê≥ï‰∏ãËΩΩËµÑÊ∫ê");
            }

            println!();
            println!("üéâ ÊÇ®Áé∞Âú®ÂèØ‰ª•‰ΩøÁî® GitAI ‰∫Ü:");
            println!("  gitai review     - ‰ª£Á†ÅËØÑÂÆ°");
            println!("  gitai commit     - Êô∫ËÉΩÊèê‰∫§");
            println!("  gitai scan       - ÂÆâÂÖ®Êâ´Êèè");
            println!("  gitai --help     - Êü•ÁúãÊõ¥Â§öÂëΩ‰ª§");
        }
        Err(e) => {
            eprintln!("‚ùå ÂàùÂßãÂåñÂ§±Ë¥•: {e}");
            return Err(e.into());
        }
    }

    Ok(())
}

#[allow(dead_code)]
async fn handle_config(
    config: &config::Config,
    action: &ConfigAction,
    offline: bool,
) -> Result<()> {
    use gitai::resource_manager::{load_resource_config, ResourceManager};

    match action {
        ConfigAction::Check => {
            println!("üîç Ê£ÄÊü•ÈÖçÁΩÆÁä∂ÊÄÅ...");

            // Ê£ÄÊü•ÈÖçÁΩÆÊñá‰ª∂
            let config_dir = dirs::home_dir()
                .unwrap_or_else(|| PathBuf::from("."))
                .join(".config/gitai");
            let config_path = config_dir.join("config.toml");

            if config_path.exists() {
                println!("‚úÖ ÈÖçÁΩÆÊñá‰ª∂: {}", config_path.display());
            } else {
                println!("‚ùå ÈÖçÁΩÆÊñá‰ª∂‰∏çÂ≠òÂú®");
            }

            // Ê£ÄÊü•ÁºìÂ≠òÁõÆÂΩï
            let cache_dir = dirs::home_dir()
                .unwrap_or_else(|| PathBuf::from("."))
                .join(".cache/gitai");

            if cache_dir.exists() {
                println!("‚úÖ ÁºìÂ≠òÁõÆÂΩï: {}", cache_dir.display());

                // Ê£ÄÊü•ËßÑÂàô
                let rules_dir = cache_dir.join("rules");
                if rules_dir.exists() {
                    println!("  ‚úÖ ËßÑÂàôÁºìÂ≠ò: Â∑≤Â∞±Áª™");
                } else {
                    println!("  ‚ö†Ô∏è  ËßÑÂàôÁºìÂ≠ò: Êú™ÊâæÂà∞");
                }

                // Ê£ÄÊü• Tree-sitter
                let ts_dir = cache_dir.join("tree-sitter");
                if ts_dir.exists() {
                    println!("  ‚úÖ Tree-sitterÁºìÂ≠ò: Â∑≤Â∞±Áª™");
                } else {
                    println!("  ‚ö†Ô∏è  Tree-sitterÁºìÂ≠ò: Êú™ÊâæÂà∞");
                }
            } else {
                println!("‚ùå ÁºìÂ≠òÁõÆÂΩï‰∏çÂ≠òÂú®");
            }
        }
        ConfigAction::Show { format } => {
            match format.as_str() {
                "json" => {
                    // Config ÂèØËÉΩÊ≤°ÊúâÂÆûÁé∞ SerializeÔºåÊöÇÊó∂Áî®ÁÆÄÂçïÊ†ºÂºè
                    println!("{{");
                    println!("  \"ai\": {{");
                    println!("    \"api_url\": \"{}\",", config.ai.api_url);
                    println!("    \"model\": \"{}\"", config.ai.model);
                    println!("  }},");
                    println!("  \"scan\": {{");
                    println!(
                        "    \"default_path\": \"{}\"",
                        config.scan.default_path.as_deref().unwrap_or(".")
                    );
                    println!("  }}");
                    println!("}}");
                }
                "toml" => {
                    // Config Á±ªÂûãÂèØËÉΩÊ≤°ÊúâÂÆûÁé∞ SerializeÔºåÊöÇÊó∂ÊòæÁ§∫ÁÆÄÂçï‰ø°ÊÅØ
                    println!("üìã TOML Ê†ºÂºèËæìÂá∫ÊöÇ‰∏çÂèØÁî®");
                }
                _ => {
                    println!("üìã ÂΩìÂâçÈÖçÁΩÆ:");
                    println!("  AIÊúçÂä°: {}", config.ai.api_url);
                    println!("  AIÊ®°Âûã: {}", config.ai.model);
                    // config.scan ÊòØ ScanConfig Á±ªÂûãÔºå‰∏çÊòØ Option
                    println!(
                        "  Êâ´ÊèèË∑ØÂæÑ: {}",
                        config.scan.default_path.as_deref().unwrap_or(".")
                    );
                }
            }
        }
        ConfigAction::Update { force } => {
            println!("üîÑ Êõ¥Êñ∞ËµÑÊ∫ê...");

            let config_path = dirs::home_dir()
                .unwrap_or_else(|| PathBuf::from("."))
                .join(".config/gitai/config.toml");

            if let Ok(resource_config) = load_resource_config(&config_path) {
                let manager = ResourceManager::new(resource_config)?;

                if offline {
                    eprintln!("‚ö†Ô∏è  Á¶ªÁ∫øÊ®°Âºè‰∏ãÊó†Ê≥ïÊõ¥Êñ∞ËµÑÊ∫ê");
                    return Ok(());
                }

                if *force {
                    println!("üöÄ Âº∫Âà∂Êõ¥Êñ∞ÊâÄÊúâËµÑÊ∫ê...");
                }

                manager.update_all().await?;
                println!("‚úÖ ËµÑÊ∫êÊõ¥Êñ∞ÂÆåÊàê");
            } else {
                eprintln!("‚ùå Êó†Ê≥ïÂä†ËΩΩËµÑÊ∫êÈÖçÁΩÆ");
            }
        }
        ConfigAction::Reset { no_backup } => {
            println!("üîÑ ÈáçÁΩÆÈÖçÁΩÆ...");

            let config_path = dirs::home_dir()
                .unwrap_or_else(|| PathBuf::from("."))
                .join(".config/gitai/config.toml");

            if !no_backup && config_path.exists() {
                let backup_path = config_path.with_extension("toml.backup");
                fs::copy(&config_path, &backup_path)?;
                println!("üíæ Â∑≤Â§á‰ªΩÂà∞: {}", backup_path.display());
            }

            // ÂÜôÂÖ•ÈªòËÆ§ÈÖçÁΩÆ
            let default_config = include_str!("../assets/config.enhanced.toml");
            fs::write(&config_path, default_config)?;
            println!("‚úÖ ÈÖçÁΩÆÂ∑≤ÈáçÁΩÆÂà∞ÈªòËÆ§ÂÄº");
        }
        ConfigAction::Clean => {
            println!("üßπ Ê∏ÖÁêÜÁºìÂ≠ò...");

            let config_path = dirs::home_dir()
                .unwrap_or_else(|| PathBuf::from("."))
                .join(".config/gitai/config.toml");

            if let Ok(resource_config) = load_resource_config(&config_path) {
                let manager = ResourceManager::new(resource_config)?;
                manager.clean_cache().await?;
                println!("‚úÖ ÁºìÂ≠òÊ∏ÖÁêÜÂÆåÊàê");
            } else {
                eprintln!("‚ùå Êó†Ê≥ïÂä†ËΩΩËµÑÊ∫êÈÖçÁΩÆ");
            }
        }
    }

    Ok(())
}

#[cfg(feature = "metrics")]
#[allow(dead_code)]
async fn handle_metrics(_config: &config::Config, action: &MetricsAction) -> Result<()> {
    use gitai::metrics::QualityTracker;
    use gitai::project_insights::InsightsGenerator;
    use gitai::tree_sitter::TreeSitterManager;

    match action {
        MetricsAction::Record { tags, force } => {
            println!("üìä ËÆ∞ÂΩï‰ª£Á†ÅË¥®ÈáèÂø´ÁÖß...");

            // Ê£ÄÊü•ÊòØÂê¶Êúâ‰ª£Á†ÅÂèòÂåñÔºàÈô§ÈùûÂº∫Âà∂ËÆ∞ÂΩïÔºâ
            if !force {
                let status = git::run_git(&["status".to_string(), "--porcelain".to_string()])?;
                if status.trim().is_empty() {
                    println!("‚ÑπÔ∏è  Ê≤°ÊúâÊ£ÄÊµãÂà∞‰ª£Á†ÅÂèòÂåñ");
                    println!("üí° ‰ΩøÁî® --force Âº∫Âà∂ËÆ∞ÂΩïÂø´ÁÖß");
                    return Ok(());
                }
            }

            // ÂàõÂª∫Ë¥®ÈáèËøΩË∏™Âô®
            let mut tracker = QualityTracker::new()?;

            // ÂàÜÊûêÂΩìÂâç‰ª£Á†Å
            println!("üîç ÂàÜÊûê‰ª£Á†ÅÁªìÊûÑ...");
            let mut manager = TreeSitterManager::new().await?;

            // Ëé∑ÂèñÂΩìÂâçÁõÆÂΩïÁöÑ‰ª£Á†ÅÊñá‰ª∂Âπ∂ÂàÜÊûê
            let mut summary = gitai::tree_sitter::StructuralSummary::default();
            let code_files = find_code_files(".")?;

            for file_path in &code_files {
                if let Ok(content) = std::fs::read_to_string(file_path) {
                    if let Some(ext) = file_path.extension().and_then(|s| s.to_str()) {
                        if let Some(lang) =
                            gitai::tree_sitter::SupportedLanguage::from_extension(ext)
                        {
                            if let Ok(file_summary) = manager.analyze_structure(&content, lang) {
                                // ÂêàÂπ∂ÁªìÊûú
                                summary.functions.extend(file_summary.functions);
                                summary.classes.extend(file_summary.classes);
                                summary.comments.extend(file_summary.comments);
                            }
                        }
                    }
                }
            }

            // ÁîüÊàêÈ°πÁõÆÊ¥ûÂØü
            println!("üí° ÁîüÊàêÈ°πÁõÆÊ¥ûÂØü...");
            let insights = InsightsGenerator::generate(&summary, None);

            // ËÆ∞ÂΩïÂø´ÁÖß
            let mut snapshot = tracker.record_snapshot(&summary, &insights)?;

            // Ê∑ªÂä†Ê†áÁ≠æ
            if !tags.is_empty() {
                snapshot.tags = tags.clone();
            }

            println!("‚úÖ Ë¥®ÈáèÂø´ÁÖßÂ∑≤ËÆ∞ÂΩï");
            println!("   Commit: {}", &snapshot.commit_hash[..7]);
            println!("   ÂàÜÊîØ: {}", snapshot.branch);
            println!("   ‰ª£Á†ÅË°åÊï∞: {}", snapshot.lines_of_code);
            println!("   ÊäÄÊúØÂÄ∫Âä°: {:.1}", snapshot.technical_debt.debt_score);
            println!(
                "   Â§çÊùÇÂ∫¶: {:.1}",
                snapshot.complexity_metrics.avg_cyclomatic_complexity
            );
        }
        MetricsAction::Analyze {
            days,
            format,
            output,
        } => {
            println!("üìà ÂàÜÊûêË¥®ÈáèË∂ãÂäø...");

            let tracker = QualityTracker::new()?;
            let analysis = tracker.analyze_trends(*days)?;

            let result = match format.as_str() {
                "json" => serde_json::to_string_pretty(&analysis)?,
                "markdown" | "html" => {
                    let visualizer = metrics::visualizer::TrendVisualizer::new();
                    if format == "html" {
                        visualizer.generate_html_report(&analysis, tracker.get_snapshots())?
                    } else {
                        visualizer.generate_report(&analysis, tracker.get_snapshots())?
                    }
                }
                _ => {
                    // ÊñáÊú¨Ê†ºÂºè
                    format!(
                        "Ë¥®ÈáèË∂ãÂäøÂàÜÊûê\n\n\
                        Êï¥‰ΩìË∂ãÂäø: {:?}\n\
                        Êó∂Èó¥ËåÉÂõ¥: {} Âà∞ {}\n\
                        Âø´ÁÖßÊï∞Èáè: {}\n\
                        ÂÖ≥ÈîÆÂèëÁé∞: {}\n\
                        ÊîπËøõÂª∫ËÆÆ: {}\n",
                        analysis.overall_trend,
                        analysis.time_range.start.format("%Y-%m-%d"),
                        analysis.time_range.end.format("%Y-%m-%d"),
                        analysis.time_range.snapshots_count,
                        analysis.key_findings.len(),
                        analysis.recommendations.len()
                    )
                }
            };

            if let Some(output_path) = output {
                std::fs::write(output_path, result)?;
                println!("üìÅ ÂàÜÊûêÁªìÊûúÂ∑≤‰øùÂ≠òÂà∞: {}", output_path.display());
            } else {
                println!("{}", result);
            }
        }
        MetricsAction::Report {
            report_type: _,
            output,
            html,
        } => {
            println!("üìÑ ÁîüÊàêË¥®ÈáèÊä•Âëä...");

            let tracker = QualityTracker::new()?;

            let report = if *html {
                let analysis = tracker.analyze_trends(None)?;
                let visualizer = metrics::visualizer::TrendVisualizer::new();
                visualizer.generate_html_report(&analysis, tracker.get_snapshots())?
            } else {
                tracker.generate_report(output.as_deref())?
            };

            if let Some(output_path) = output {
                std::fs::write(output_path, report)?;
                println!("‚úÖ Êä•ÂëäÂ∑≤ÁîüÊàê: {}", output_path.display());
            } else {
                println!("{}", report);
            }
        }
        MetricsAction::List {
            limit,
            branch,
            format,
        } => {
            let tracker = QualityTracker::new()?;
            let snapshots = tracker.get_snapshots();

            // ËøáÊª§ÂàÜÊîØ
            let filtered: Vec<_> = if let Some(branch_name) = branch {
                snapshots
                    .iter()
                    .filter(|s| s.branch == *branch_name)
                    .collect()
            } else {
                snapshots.iter().collect()
            };

            match format.as_str() {
                "json" => {
                    let json = serde_json::to_string_pretty(
                        &filtered.into_iter().take(*limit).collect::<Vec<_>>(),
                    )?;
                    println!("{}", json);
                }
                "table" | _ => {
                    println!("üìã ÂéÜÂè≤Âø´ÁÖß (ÊúÄËøë{}‰∏™):", limit);
                    println!("‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê");
                    println!("‚îÇ #  ‚îÇ Êó∂Èó¥         ‚îÇ Commit  ‚îÇ LOC  ‚îÇ ÂÄ∫Âä°    ‚îÇ Â§çÊùÇÂ∫¶ ‚îÇ APIÁ®≥ÂÆö‚îÇ");
                    println!("‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§");

                    for (i, snapshot) in filtered.iter().rev().take(*limit).enumerate() {
                        println!(
                            "‚îÇ{:3} ‚îÇ {} ‚îÇ {:7} ‚îÇ{:5} ‚îÇ{:8.1} ‚îÇ{:7.1} ‚îÇ{:7.0}%‚îÇ",
                            i + 1,
                            snapshot.timestamp.format("%m-%d %H:%M"),
                            &snapshot.commit_hash[..7],
                            snapshot.lines_of_code,
                            snapshot.technical_debt.debt_score,
                            snapshot.complexity_metrics.avg_cyclomatic_complexity,
                            snapshot.api_metrics.stability_score,
                        );
                    }
                    println!("‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò");
                }
            }
        }
        MetricsAction::Compare { from, to, format } => {
            let tracker = QualityTracker::new()?;
            let snapshots = tracker.get_snapshots();

            // Êü•ÊâæÂø´ÁÖß
            let from_snapshot = if from == "latest" {
                snapshots.last()
            } else if let Ok(index) = from.parse::<usize>() {
                snapshots.get(index.saturating_sub(1))
            } else {
                snapshots.iter().find(|s| s.commit_hash.starts_with(from))
            };

            let to_snapshot = if let Some(to_ref) = to {
                if to_ref == "latest" {
                    snapshots.last()
                } else if let Ok(index) = to_ref.parse::<usize>() {
                    snapshots.get(index.saturating_sub(1))
                } else {
                    snapshots.iter().find(|s| s.commit_hash.starts_with(to_ref))
                }
            } else {
                snapshots.last()
            };

            match (from_snapshot, to_snapshot) {
                (Some(from_s), Some(to_s)) => {
                    let changes = tracker.compare_snapshots(from_s, to_s);

                    if format == "json" {
                        println!("{}", serde_json::to_string_pretty(&changes)?);
                    } else {
                        println!("üìä Âø´ÁÖßÊØîËæÉ:");
                        println!(
                            "   ‰ªé: {} ({})",
                            &from_s.commit_hash[..7],
                            from_s.timestamp.format("%Y-%m-%d")
                        );
                        println!(
                            "   Âà∞: {} ({})",
                            &to_s.commit_hash[..7],
                            to_s.timestamp.format("%Y-%m-%d")
                        );
                        println!();
                        println!("   ÂèòÂåñ:");
                        for (key, value) in &changes {
                            let emoji = if *value > 0.0 {
                                "üìà"
                            } else if *value < 0.0 {
                                "üìâ"
                            } else {
                                "‚û°Ô∏è"
                            };
                            println!("     {} {}: {:+.2}", emoji, key, value);
                        }
                    }
                }
                _ => {
                    eprintln!("‚ùå Êú™ÊâæÂà∞ÊåáÂÆöÁöÑÂø´ÁÖß");
                }
            }
        }
        MetricsAction::Clean { keep_days, yes } => {
            if !yes {
                println!("‚ö†Ô∏è  Á°ÆËÆ§Ê∏ÖÁêÜË∂ÖËøá{}Â§©ÁöÑÂéÜÂè≤Êï∞ÊçÆÔºü‰ΩøÁî® --yes Á°ÆËÆ§", keep_days);
                return Ok(());
            }

            let mut tracker = QualityTracker::new()?;
            let removed = tracker.cleanup_old_snapshots(*keep_days)?;
            println!("üßπ Â∑≤Ê∏ÖÁêÜ {} ‰∏™ÊóßÂø´ÁÖß", removed);
        }
        MetricsAction::Export {
            format,
            output,
            branches,
        } => {
            println!("üì§ ÂØºÂá∫Ë¥®ÈáèÊï∞ÊçÆ...");

            let tracker = QualityTracker::new()?;
            let snapshots = if branches.is_empty() {
                tracker.get_snapshots().to_vec()
            } else {
                tracker
                    .get_snapshots()
                    .iter()
                    .filter(|s| branches.contains(&s.branch))
                    .cloned()
                    .collect()
            };

            match format.as_str() {
                "csv" => {
                    metrics::storage::export_to_csv(&snapshots, output)?;
                    println!("‚úÖ Â∑≤ÂØºÂá∫Âà∞: {}", output.display());
                }
                "json" => {
                    let json = serde_json::to_string_pretty(&snapshots)?;
                    std::fs::write(output, json)?;
                    println!("‚úÖ Â∑≤ÂØºÂá∫Âà∞: {}", output.display());
                }
                _ => {
                    eprintln!("‚ùå ‰∏çÊîØÊåÅÁöÑÂØºÂá∫Ê†ºÂºè: {}", format);
                }
            }
        }
    }

    Ok(())
}

// ËæÖÂä©ÂáΩÊï∞ÔºöÊü•Êâæ‰ª£Á†ÅÊñá‰ª∂
/// ‰∏ãËΩΩ Tree-sitter ËµÑÊ∫ê
#[allow(dead_code)]
async fn download_tree_sitter_resources() -> Result<()> {
    // ÂàõÂª∫ TreeSitterManager ÂÆû‰æãÔºåËøôÈÄöÂ∏∏‰ºöËß¶ÂèëÂàùÂßãÂåñÂíå‰∏ãËΩΩ
    // Ê£ÄÊü•ÊòØÂê¶ÂêØÁî®‰∫Ü‰ªªÊÑè Tree-sitter ËØ≠Ë®ÄÊîØÊåÅ
    #[cfg(any(
        feature = "tree-sitter-rust",
        feature = "tree-sitter-java",
        feature = "tree-sitter-python",
        feature = "tree-sitter-javascript",
        feature = "tree-sitter-typescript",
        feature = "tree-sitter-go",
        feature = "tree-sitter-c",
        feature = "tree-sitter-cpp"
    ))]
    {
        match gitai::tree_sitter::TreeSitterManager::new().await {
            Ok(_) => {
                log::info!("Tree-sitter ËµÑÊ∫êÂàùÂßãÂåñÊàêÂäü");
                Ok(())
            }
            Err(e) => {
                log::warn!("Tree-sitter ËµÑÊ∫êÂàùÂßãÂåñÂ§±Ë¥•: {e}");
                Err(format!("Tree-sitter ËµÑÊ∫ê‰∏ãËΩΩÂ§±Ë¥•: {e}").into())
            }
        }
    }
    #[cfg(not(any(
        feature = "tree-sitter-rust",
        feature = "tree-sitter-java",
        feature = "tree-sitter-python",
        feature = "tree-sitter-javascript",
        feature = "tree-sitter-typescript",
        feature = "tree-sitter-go",
        feature = "tree-sitter-c",
        feature = "tree-sitter-cpp"
    )))]
    {
        log::info!("Tree-sitter ÂäüËÉΩÊú™ÂêØÁî®ÔºåË∑≥ËøáËµÑÊ∫ê‰∏ãËΩΩ");
        Ok(())
    }
}

/// ‰∏ãËΩΩ OpenGrep ËßÑÂàôËµÑÊ∫ê
#[allow(dead_code)]
async fn download_opengrep_resources(_config_path: &std::path::Path) -> Result<()> {
    #[cfg(feature = "security")]
    {
        use gitai::resource_manager::{load_resource_config, ResourceManager};

        // Â∞ùËØïÂä†ËΩΩËµÑÊ∫êÈÖçÁΩÆ
        match load_resource_config(_config_path) {
            Ok(resource_config) => {
                let manager = ResourceManager::new(resource_config)?;
                match manager.update_all().await {
                    Ok(_) => {
                        log::info!("OpenGrep ËßÑÂàôËµÑÊ∫êÊõ¥Êñ∞ÊàêÂäü");
                        Ok(())
                    }
                    Err(e) => {
                        log::warn!("OpenGrep ËßÑÂàôËµÑÊ∫êÊõ¥Êñ∞Â§±Ë¥•: {}", e);
                        Err(format!("OpenGrep ËßÑÂàô‰∏ãËΩΩÂ§±Ë¥•: {}", e).into())
                    }
                }
            }
            Err(e) => {
                log::warn!("Êó†Ê≥ïÂä†ËΩΩËµÑÊ∫êÈÖçÁΩÆ: {}", e);
                // ‰∏çÂ∞ÜÊ≠§ËßÜ‰∏∫ÈîôËØØÔºåÂõ†‰∏∫ÂèØËÉΩÈÖçÁΩÆËøòÊú™ÂÆåÂÖ®ËÆæÁΩÆ
                Ok(())
            }
        }
    }
    #[cfg(not(feature = "security"))]
    {
        log::info!("ÂÆâÂÖ®Êâ´ÊèèÂäüËÉΩÊú™ÂêØÁî®ÔºåË∑≥Ëøá OpenGrep ËßÑÂàô‰∏ãËΩΩ");
        Ok(())
    }
}

// ËæÖÂä©ÂáΩÊï∞ÔºöÊü•Êâæ‰ª£Á†ÅÊñá‰ª∂
#[cfg(feature = "metrics")]
#[allow(dead_code)]
fn find_code_files(dir: &str) -> Result<Vec<PathBuf>> {
    let mut files = Vec::new();
    let supported_extensions = ["rs", "java", "py", "js", "ts", "go", "c", "cpp"];

    for entry in walkdir::WalkDir::new(dir)
        .into_iter()
        .filter_map(|e| e.ok())
        .filter(|e| !e.file_type().is_dir())
    {
        let path = entry.path();

        // Ë∑≥ËøáÈöêËóèÁõÆÂΩïÂíåÂ∏∏ËßÅÁöÑÊéíÈô§ÁõÆÂΩï
        if path.components().any(|c| {
            c.as_os_str().to_str().is_some_and(|s| {
                s.starts_with('.') || s == "target" || s == "node_modules" || s == "build"
            })
        }) {
            continue;
        }

        if let Some(ext) = path.extension().and_then(|s| s.to_str()) {
            if supported_extensions.contains(&ext) {
                files.push(path.to_path_buf());
            }
        }
    }

    Ok(files)
}
